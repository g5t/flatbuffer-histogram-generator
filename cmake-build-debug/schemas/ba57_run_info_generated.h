// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BA57RUNINFO_H_
#define FLATBUFFERS_GENERATED_BA57RUNINFO_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

struct RunStart;
struct RunStartBuilder;

struct RunStop;
struct RunStopBuilder;

struct RunInfo;
struct RunInfoBuilder;

enum class InfoTypes : uint8_t {
  NONE = 0,
  RunStart = 1,
  RunStop = 2,
  MIN = NONE,
  MAX = RunStop
};

inline const InfoTypes (&EnumValuesInfoTypes())[3] {
  static const InfoTypes values[] = {
    InfoTypes::NONE,
    InfoTypes::RunStart,
    InfoTypes::RunStop
  };
  return values;
}

inline const char * const *EnumNamesInfoTypes() {
  static const char * const names[4] = {
    "NONE",
    "RunStart",
    "RunStop",
    nullptr
  };
  return names;
}

inline const char *EnumNameInfoTypes(InfoTypes e) {
  if (::flatbuffers::IsOutRange(e, InfoTypes::NONE, InfoTypes::RunStop)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesInfoTypes()[index];
}

template<typename T> struct InfoTypesTraits {
  static const InfoTypes enum_value = InfoTypes::NONE;
};

template<> struct InfoTypesTraits<RunStart> {
  static const InfoTypes enum_value = InfoTypes::RunStart;
};

template<> struct InfoTypesTraits<RunStop> {
  static const InfoTypes enum_value = InfoTypes::RunStop;
};

bool VerifyInfoTypes(::flatbuffers::Verifier &verifier, const void *obj, InfoTypes type);
bool VerifyInfoTypesVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<InfoTypes> *types);

struct RunStart FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RunStartBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "RunStart";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_START_TIME = 4,
    VT_RUN_NUMBER = 6,
    VT_INSTRUMENT_NAME = 8,
    VT_N_PERIODS = 10
  };
  uint64_t start_time() const {
    return GetField<uint64_t>(VT_START_TIME, 0);
  }
  bool mutate_start_time(uint64_t _start_time = 0) {
    return SetField<uint64_t>(VT_START_TIME, _start_time, 0);
  }
  int32_t run_number() const {
    return GetField<int32_t>(VT_RUN_NUMBER, 0);
  }
  bool mutate_run_number(int32_t _run_number = 0) {
    return SetField<int32_t>(VT_RUN_NUMBER, _run_number, 0);
  }
  const ::flatbuffers::String *instrument_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INSTRUMENT_NAME);
  }
  ::flatbuffers::String *mutable_instrument_name() {
    return GetPointer<::flatbuffers::String *>(VT_INSTRUMENT_NAME);
  }
  int32_t n_periods() const {
    return GetField<int32_t>(VT_N_PERIODS, 0);
  }
  bool mutate_n_periods(int32_t _n_periods = 0) {
    return SetField<int32_t>(VT_N_PERIODS, _n_periods, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_START_TIME, 8) &&
           VerifyField<int32_t>(verifier, VT_RUN_NUMBER, 4) &&
           VerifyOffset(verifier, VT_INSTRUMENT_NAME) &&
           verifier.VerifyString(instrument_name()) &&
           VerifyField<int32_t>(verifier, VT_N_PERIODS, 4) &&
           verifier.EndTable();
  }
};

struct RunStartBuilder {
  typedef RunStart Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_start_time(uint64_t start_time) {
    fbb_.AddElement<uint64_t>(RunStart::VT_START_TIME, start_time, 0);
  }
  void add_run_number(int32_t run_number) {
    fbb_.AddElement<int32_t>(RunStart::VT_RUN_NUMBER, run_number, 0);
  }
  void add_instrument_name(::flatbuffers::Offset<::flatbuffers::String> instrument_name) {
    fbb_.AddOffset(RunStart::VT_INSTRUMENT_NAME, instrument_name);
  }
  void add_n_periods(int32_t n_periods) {
    fbb_.AddElement<int32_t>(RunStart::VT_N_PERIODS, n_periods, 0);
  }
  explicit RunStartBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RunStart> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RunStart>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RunStart> CreateRunStart(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t start_time = 0,
    int32_t run_number = 0,
    ::flatbuffers::Offset<::flatbuffers::String> instrument_name = 0,
    int32_t n_periods = 0) {
  RunStartBuilder builder_(_fbb);
  builder_.add_start_time(start_time);
  builder_.add_n_periods(n_periods);
  builder_.add_instrument_name(instrument_name);
  builder_.add_run_number(run_number);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RunStart> CreateRunStartDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t start_time = 0,
    int32_t run_number = 0,
    const char *instrument_name = nullptr,
    int32_t n_periods = 0) {
  auto instrument_name__ = instrument_name ? _fbb.CreateString(instrument_name) : 0;
  return CreateRunStart(
      _fbb,
      start_time,
      run_number,
      instrument_name__,
      n_periods);
}

struct RunStop FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RunStopBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "RunStop";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STOP_TIME = 4,
    VT_RUN_NUMBER = 6
  };
  uint64_t stop_time() const {
    return GetField<uint64_t>(VT_STOP_TIME, 0);
  }
  bool mutate_stop_time(uint64_t _stop_time = 0) {
    return SetField<uint64_t>(VT_STOP_TIME, _stop_time, 0);
  }
  int32_t run_number() const {
    return GetField<int32_t>(VT_RUN_NUMBER, 0);
  }
  bool mutate_run_number(int32_t _run_number = 0) {
    return SetField<int32_t>(VT_RUN_NUMBER, _run_number, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_STOP_TIME, 8) &&
           VerifyField<int32_t>(verifier, VT_RUN_NUMBER, 4) &&
           verifier.EndTable();
  }
};

struct RunStopBuilder {
  typedef RunStop Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_stop_time(uint64_t stop_time) {
    fbb_.AddElement<uint64_t>(RunStop::VT_STOP_TIME, stop_time, 0);
  }
  void add_run_number(int32_t run_number) {
    fbb_.AddElement<int32_t>(RunStop::VT_RUN_NUMBER, run_number, 0);
  }
  explicit RunStopBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RunStop> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RunStop>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RunStop> CreateRunStop(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t stop_time = 0,
    int32_t run_number = 0) {
  RunStopBuilder builder_(_fbb);
  builder_.add_stop_time(stop_time);
  builder_.add_run_number(run_number);
  return builder_.Finish();
}

struct RunInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RunInfoBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "RunInfo";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFO_TYPE_TYPE = 4,
    VT_INFO_TYPE = 6
  };
  InfoTypes info_type_type() const {
    return static_cast<InfoTypes>(GetField<uint8_t>(VT_INFO_TYPE_TYPE, 0));
  }
  const void *info_type() const {
    return GetPointer<const void *>(VT_INFO_TYPE);
  }
  template<typename T> const T *info_type_as() const;
  const RunStart *info_type_as_RunStart() const {
    return info_type_type() == InfoTypes::RunStart ? static_cast<const RunStart *>(info_type()) : nullptr;
  }
  const RunStop *info_type_as_RunStop() const {
    return info_type_type() == InfoTypes::RunStop ? static_cast<const RunStop *>(info_type()) : nullptr;
  }
  void *mutable_info_type() {
    return GetPointer<void *>(VT_INFO_TYPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_INFO_TYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_INFO_TYPE) &&
           VerifyInfoTypes(verifier, info_type(), info_type_type()) &&
           verifier.EndTable();
  }
};

template<> inline const RunStart *RunInfo::info_type_as<RunStart>() const {
  return info_type_as_RunStart();
}

template<> inline const RunStop *RunInfo::info_type_as<RunStop>() const {
  return info_type_as_RunStop();
}

struct RunInfoBuilder {
  typedef RunInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_info_type_type(InfoTypes info_type_type) {
    fbb_.AddElement<uint8_t>(RunInfo::VT_INFO_TYPE_TYPE, static_cast<uint8_t>(info_type_type), 0);
  }
  void add_info_type(::flatbuffers::Offset<void> info_type) {
    fbb_.AddOffset(RunInfo::VT_INFO_TYPE, info_type);
  }
  explicit RunInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RunInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RunInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RunInfo> CreateRunInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    InfoTypes info_type_type = InfoTypes::NONE,
    ::flatbuffers::Offset<void> info_type = 0) {
  RunInfoBuilder builder_(_fbb);
  builder_.add_info_type(info_type);
  builder_.add_info_type_type(info_type_type);
  return builder_.Finish();
}

inline bool VerifyInfoTypes(::flatbuffers::Verifier &verifier, const void *obj, InfoTypes type) {
  switch (type) {
    case InfoTypes::NONE: {
      return true;
    }
    case InfoTypes::RunStart: {
      auto ptr = reinterpret_cast<const RunStart *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InfoTypes::RunStop: {
      auto ptr = reinterpret_cast<const RunStop *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyInfoTypesVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<InfoTypes> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyInfoTypes(
        verifier,  values->Get(i), types->GetEnum<InfoTypes>(i))) {
      return false;
    }
  }
  return true;
}

inline const RunInfo *GetRunInfo(const void *buf) {
  return ::flatbuffers::GetRoot<RunInfo>(buf);
}

inline const RunInfo *GetSizePrefixedRunInfo(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<RunInfo>(buf);
}

inline RunInfo *GetMutableRunInfo(void *buf) {
  return ::flatbuffers::GetMutableRoot<RunInfo>(buf);
}

inline RunInfo *GetMutableSizePrefixedRunInfo(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<RunInfo>(buf);
}

inline const char *RunInfoIdentifier() {
  return "ba57";
}

inline bool RunInfoBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, RunInfoIdentifier());
}

inline bool SizePrefixedRunInfoBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, RunInfoIdentifier(), true);
}

inline bool VerifyRunInfoBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<RunInfo>(RunInfoIdentifier());
}

inline bool VerifySizePrefixedRunInfoBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<RunInfo>(RunInfoIdentifier());
}

inline void FinishRunInfoBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<RunInfo> root) {
  fbb.Finish(root, RunInfoIdentifier());
}

inline void FinishSizePrefixedRunInfoBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<RunInfo> root) {
  fbb.FinishSizePrefixed(root, RunInfoIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_BA57RUNINFO_H_
