// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MO01NMX_H_
#define FLATBUFFERS_GENERATED_MO01NMX_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

struct pos;
struct posBuilder;

struct MONHit;
struct MONHitBuilder;

struct GEMTrack;
struct GEMTrackBuilder;

struct GEMHist;
struct GEMHistBuilder;

struct MonitorMessage;
struct MonitorMessageBuilder;

enum class DataField : uint8_t {
  NONE = 0,
  GEMHist = 1,
  GEMTrack = 2,
  MONHit = 3,
  MIN = NONE,
  MAX = MONHit
};

inline const DataField (&EnumValuesDataField())[4] {
  static const DataField values[] = {
    DataField::NONE,
    DataField::GEMHist,
    DataField::GEMTrack,
    DataField::MONHit
  };
  return values;
}

inline const char * const *EnumNamesDataField() {
  static const char * const names[5] = {
    "NONE",
    "GEMHist",
    "GEMTrack",
    "MONHit",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataField(DataField e) {
  if (::flatbuffers::IsOutRange(e, DataField::NONE, DataField::MONHit)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataField()[index];
}

template<typename T> struct DataFieldTraits {
  static const DataField enum_value = DataField::NONE;
};

template<> struct DataFieldTraits<GEMHist> {
  static const DataField enum_value = DataField::GEMHist;
};

template<> struct DataFieldTraits<GEMTrack> {
  static const DataField enum_value = DataField::GEMTrack;
};

template<> struct DataFieldTraits<MONHit> {
  static const DataField enum_value = DataField::MONHit;
};

bool VerifyDataField(::flatbuffers::Verifier &verifier, const void *obj, DataField type);
bool VerifyDataFieldVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<DataField> *types);

struct pos FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef posBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "pos";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_STRIP = 6,
    VT_ADC = 8
  };
  uint16_t time() const {
    return GetField<uint16_t>(VT_TIME, 0);
  }
  bool mutate_time(uint16_t _time = 0) {
    return SetField<uint16_t>(VT_TIME, _time, 0);
  }
  uint16_t strip() const {
    return GetField<uint16_t>(VT_STRIP, 0);
  }
  bool mutate_strip(uint16_t _strip = 0) {
    return SetField<uint16_t>(VT_STRIP, _strip, 0);
  }
  uint16_t adc() const {
    return GetField<uint16_t>(VT_ADC, 0);
  }
  bool mutate_adc(uint16_t _adc = 0) {
    return SetField<uint16_t>(VT_ADC, _adc, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_TIME, 2) &&
           VerifyField<uint16_t>(verifier, VT_STRIP, 2) &&
           VerifyField<uint16_t>(verifier, VT_ADC, 2) &&
           verifier.EndTable();
  }
};

struct posBuilder {
  typedef pos Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_time(uint16_t time) {
    fbb_.AddElement<uint16_t>(pos::VT_TIME, time, 0);
  }
  void add_strip(uint16_t strip) {
    fbb_.AddElement<uint16_t>(pos::VT_STRIP, strip, 0);
  }
  void add_adc(uint16_t adc) {
    fbb_.AddElement<uint16_t>(pos::VT_ADC, adc, 0);
  }
  explicit posBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<pos> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<pos>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<pos> Createpos(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t time = 0,
    uint16_t strip = 0,
    uint16_t adc = 0) {
  posBuilder builder_(_fbb);
  builder_.add_adc(adc);
  builder_.add_strip(strip);
  builder_.add_time(time);
  return builder_.Finish();
}

struct MONHit FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MONHitBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "MONHit";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLANE = 4,
    VT_TIME = 6,
    VT_CHANNEL = 8,
    VT_ADC = 10
  };
  const ::flatbuffers::Vector<uint16_t> *plane() const {
    return GetPointer<const ::flatbuffers::Vector<uint16_t> *>(VT_PLANE);
  }
  ::flatbuffers::Vector<uint16_t> *mutable_plane() {
    return GetPointer<::flatbuffers::Vector<uint16_t> *>(VT_PLANE);
  }
  const ::flatbuffers::Vector<uint32_t> *time() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_TIME);
  }
  ::flatbuffers::Vector<uint32_t> *mutable_time() {
    return GetPointer<::flatbuffers::Vector<uint32_t> *>(VT_TIME);
  }
  const ::flatbuffers::Vector<uint16_t> *channel() const {
    return GetPointer<const ::flatbuffers::Vector<uint16_t> *>(VT_CHANNEL);
  }
  ::flatbuffers::Vector<uint16_t> *mutable_channel() {
    return GetPointer<::flatbuffers::Vector<uint16_t> *>(VT_CHANNEL);
  }
  const ::flatbuffers::Vector<uint16_t> *adc() const {
    return GetPointer<const ::flatbuffers::Vector<uint16_t> *>(VT_ADC);
  }
  ::flatbuffers::Vector<uint16_t> *mutable_adc() {
    return GetPointer<::flatbuffers::Vector<uint16_t> *>(VT_ADC);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PLANE) &&
           verifier.VerifyVector(plane()) &&
           VerifyOffset(verifier, VT_TIME) &&
           verifier.VerifyVector(time()) &&
           VerifyOffset(verifier, VT_CHANNEL) &&
           verifier.VerifyVector(channel()) &&
           VerifyOffset(verifier, VT_ADC) &&
           verifier.VerifyVector(adc()) &&
           verifier.EndTable();
  }
};

struct MONHitBuilder {
  typedef MONHit Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_plane(::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> plane) {
    fbb_.AddOffset(MONHit::VT_PLANE, plane);
  }
  void add_time(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> time) {
    fbb_.AddOffset(MONHit::VT_TIME, time);
  }
  void add_channel(::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> channel) {
    fbb_.AddOffset(MONHit::VT_CHANNEL, channel);
  }
  void add_adc(::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> adc) {
    fbb_.AddOffset(MONHit::VT_ADC, adc);
  }
  explicit MONHitBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MONHit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MONHit>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MONHit> CreateMONHit(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> plane = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> time = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> channel = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> adc = 0) {
  MONHitBuilder builder_(_fbb);
  builder_.add_adc(adc);
  builder_.add_channel(channel);
  builder_.add_time(time);
  builder_.add_plane(plane);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MONHit> CreateMONHitDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint16_t> *plane = nullptr,
    const std::vector<uint32_t> *time = nullptr,
    const std::vector<uint16_t> *channel = nullptr,
    const std::vector<uint16_t> *adc = nullptr) {
  auto plane__ = plane ? _fbb.CreateVector<uint16_t>(*plane) : 0;
  auto time__ = time ? _fbb.CreateVector<uint32_t>(*time) : 0;
  auto channel__ = channel ? _fbb.CreateVector<uint16_t>(*channel) : 0;
  auto adc__ = adc ? _fbb.CreateVector<uint16_t>(*adc) : 0;
  return CreateMONHit(
      _fbb,
      plane__,
      time__,
      channel__,
      adc__);
}

struct GEMTrack FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GEMTrackBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "GEMTrack";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME_OFFSET = 4,
    VT_XTRACK = 6,
    VT_YTRACK = 8,
    VT_XPOS = 10,
    VT_YPOS = 12
  };
  uint64_t time_offset() const {
    return GetField<uint64_t>(VT_TIME_OFFSET, 0);
  }
  bool mutate_time_offset(uint64_t _time_offset = 0) {
    return SetField<uint64_t>(VT_TIME_OFFSET, _time_offset, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<pos>> *xtrack() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<pos>> *>(VT_XTRACK);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<pos>> *mutable_xtrack() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<pos>> *>(VT_XTRACK);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<pos>> *ytrack() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<pos>> *>(VT_YTRACK);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<pos>> *mutable_ytrack() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<pos>> *>(VT_YTRACK);
  }
  double xpos() const {
    return GetField<double>(VT_XPOS, 0.0);
  }
  bool mutate_xpos(double _xpos = 0.0) {
    return SetField<double>(VT_XPOS, _xpos, 0.0);
  }
  double ypos() const {
    return GetField<double>(VT_YPOS, 0.0);
  }
  bool mutate_ypos(double _ypos = 0.0) {
    return SetField<double>(VT_YPOS, _ypos, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TIME_OFFSET, 8) &&
           VerifyOffset(verifier, VT_XTRACK) &&
           verifier.VerifyVector(xtrack()) &&
           verifier.VerifyVectorOfTables(xtrack()) &&
           VerifyOffset(verifier, VT_YTRACK) &&
           verifier.VerifyVector(ytrack()) &&
           verifier.VerifyVectorOfTables(ytrack()) &&
           VerifyField<double>(verifier, VT_XPOS, 8) &&
           VerifyField<double>(verifier, VT_YPOS, 8) &&
           verifier.EndTable();
  }
};

struct GEMTrackBuilder {
  typedef GEMTrack Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_time_offset(uint64_t time_offset) {
    fbb_.AddElement<uint64_t>(GEMTrack::VT_TIME_OFFSET, time_offset, 0);
  }
  void add_xtrack(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<pos>>> xtrack) {
    fbb_.AddOffset(GEMTrack::VT_XTRACK, xtrack);
  }
  void add_ytrack(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<pos>>> ytrack) {
    fbb_.AddOffset(GEMTrack::VT_YTRACK, ytrack);
  }
  void add_xpos(double xpos) {
    fbb_.AddElement<double>(GEMTrack::VT_XPOS, xpos, 0.0);
  }
  void add_ypos(double ypos) {
    fbb_.AddElement<double>(GEMTrack::VT_YPOS, ypos, 0.0);
  }
  explicit GEMTrackBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GEMTrack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GEMTrack>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GEMTrack> CreateGEMTrack(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t time_offset = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<pos>>> xtrack = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<pos>>> ytrack = 0,
    double xpos = 0.0,
    double ypos = 0.0) {
  GEMTrackBuilder builder_(_fbb);
  builder_.add_ypos(ypos);
  builder_.add_xpos(xpos);
  builder_.add_time_offset(time_offset);
  builder_.add_ytrack(ytrack);
  builder_.add_xtrack(xtrack);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GEMTrack> CreateGEMTrackDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t time_offset = 0,
    const std::vector<::flatbuffers::Offset<pos>> *xtrack = nullptr,
    const std::vector<::flatbuffers::Offset<pos>> *ytrack = nullptr,
    double xpos = 0.0,
    double ypos = 0.0) {
  auto xtrack__ = xtrack ? _fbb.CreateVector<::flatbuffers::Offset<pos>>(*xtrack) : 0;
  auto ytrack__ = ytrack ? _fbb.CreateVector<::flatbuffers::Offset<pos>>(*ytrack) : 0;
  return CreateGEMTrack(
      _fbb,
      time_offset,
      xtrack__,
      ytrack__,
      xpos,
      ypos);
}

struct GEMHist FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GEMHistBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "GEMHist";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_XSTRIPS = 4,
    VT_YSTRIPS = 6,
    VT_XSPECTRUM = 8,
    VT_YSPECTRUM = 10,
    VT_CLUSTER_SPECTRUM = 12,
    VT_BIN_WIDTH = 14
  };
  const ::flatbuffers::Vector<uint32_t> *xstrips() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_XSTRIPS);
  }
  ::flatbuffers::Vector<uint32_t> *mutable_xstrips() {
    return GetPointer<::flatbuffers::Vector<uint32_t> *>(VT_XSTRIPS);
  }
  const ::flatbuffers::Vector<uint32_t> *ystrips() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_YSTRIPS);
  }
  ::flatbuffers::Vector<uint32_t> *mutable_ystrips() {
    return GetPointer<::flatbuffers::Vector<uint32_t> *>(VT_YSTRIPS);
  }
  const ::flatbuffers::Vector<uint32_t> *xspectrum() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_XSPECTRUM);
  }
  ::flatbuffers::Vector<uint32_t> *mutable_xspectrum() {
    return GetPointer<::flatbuffers::Vector<uint32_t> *>(VT_XSPECTRUM);
  }
  const ::flatbuffers::Vector<uint32_t> *yspectrum() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_YSPECTRUM);
  }
  ::flatbuffers::Vector<uint32_t> *mutable_yspectrum() {
    return GetPointer<::flatbuffers::Vector<uint32_t> *>(VT_YSPECTRUM);
  }
  const ::flatbuffers::Vector<uint32_t> *cluster_spectrum() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_CLUSTER_SPECTRUM);
  }
  ::flatbuffers::Vector<uint32_t> *mutable_cluster_spectrum() {
    return GetPointer<::flatbuffers::Vector<uint32_t> *>(VT_CLUSTER_SPECTRUM);
  }
  uint32_t bin_width() const {
    return GetField<uint32_t>(VT_BIN_WIDTH, 0);
  }
  bool mutate_bin_width(uint32_t _bin_width = 0) {
    return SetField<uint32_t>(VT_BIN_WIDTH, _bin_width, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_XSTRIPS) &&
           verifier.VerifyVector(xstrips()) &&
           VerifyOffset(verifier, VT_YSTRIPS) &&
           verifier.VerifyVector(ystrips()) &&
           VerifyOffset(verifier, VT_XSPECTRUM) &&
           verifier.VerifyVector(xspectrum()) &&
           VerifyOffset(verifier, VT_YSPECTRUM) &&
           verifier.VerifyVector(yspectrum()) &&
           VerifyOffset(verifier, VT_CLUSTER_SPECTRUM) &&
           verifier.VerifyVector(cluster_spectrum()) &&
           VerifyField<uint32_t>(verifier, VT_BIN_WIDTH, 4) &&
           verifier.EndTable();
  }
};

struct GEMHistBuilder {
  typedef GEMHist Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_xstrips(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> xstrips) {
    fbb_.AddOffset(GEMHist::VT_XSTRIPS, xstrips);
  }
  void add_ystrips(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> ystrips) {
    fbb_.AddOffset(GEMHist::VT_YSTRIPS, ystrips);
  }
  void add_xspectrum(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> xspectrum) {
    fbb_.AddOffset(GEMHist::VT_XSPECTRUM, xspectrum);
  }
  void add_yspectrum(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> yspectrum) {
    fbb_.AddOffset(GEMHist::VT_YSPECTRUM, yspectrum);
  }
  void add_cluster_spectrum(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> cluster_spectrum) {
    fbb_.AddOffset(GEMHist::VT_CLUSTER_SPECTRUM, cluster_spectrum);
  }
  void add_bin_width(uint32_t bin_width) {
    fbb_.AddElement<uint32_t>(GEMHist::VT_BIN_WIDTH, bin_width, 0);
  }
  explicit GEMHistBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GEMHist> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GEMHist>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GEMHist> CreateGEMHist(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> xstrips = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> ystrips = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> xspectrum = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> yspectrum = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> cluster_spectrum = 0,
    uint32_t bin_width = 0) {
  GEMHistBuilder builder_(_fbb);
  builder_.add_bin_width(bin_width);
  builder_.add_cluster_spectrum(cluster_spectrum);
  builder_.add_yspectrum(yspectrum);
  builder_.add_xspectrum(xspectrum);
  builder_.add_ystrips(ystrips);
  builder_.add_xstrips(xstrips);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GEMHist> CreateGEMHistDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *xstrips = nullptr,
    const std::vector<uint32_t> *ystrips = nullptr,
    const std::vector<uint32_t> *xspectrum = nullptr,
    const std::vector<uint32_t> *yspectrum = nullptr,
    const std::vector<uint32_t> *cluster_spectrum = nullptr,
    uint32_t bin_width = 0) {
  auto xstrips__ = xstrips ? _fbb.CreateVector<uint32_t>(*xstrips) : 0;
  auto ystrips__ = ystrips ? _fbb.CreateVector<uint32_t>(*ystrips) : 0;
  auto xspectrum__ = xspectrum ? _fbb.CreateVector<uint32_t>(*xspectrum) : 0;
  auto yspectrum__ = yspectrum ? _fbb.CreateVector<uint32_t>(*yspectrum) : 0;
  auto cluster_spectrum__ = cluster_spectrum ? _fbb.CreateVector<uint32_t>(*cluster_spectrum) : 0;
  return CreateGEMHist(
      _fbb,
      xstrips__,
      ystrips__,
      xspectrum__,
      yspectrum__,
      cluster_spectrum__,
      bin_width);
}

struct MonitorMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MonitorMessageBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "MonitorMessage";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOURCE_NAME = 4,
    VT_DATA_TYPE = 6,
    VT_DATA = 8
  };
  const ::flatbuffers::String *source_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE_NAME);
  }
  ::flatbuffers::String *mutable_source_name() {
    return GetPointer<::flatbuffers::String *>(VT_SOURCE_NAME);
  }
  DataField data_type() const {
    return static_cast<DataField>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const GEMHist *data_as_GEMHist() const {
    return data_type() == DataField::GEMHist ? static_cast<const GEMHist *>(data()) : nullptr;
  }
  const GEMTrack *data_as_GEMTrack() const {
    return data_type() == DataField::GEMTrack ? static_cast<const GEMTrack *>(data()) : nullptr;
  }
  const MONHit *data_as_MONHit() const {
    return data_type() == DataField::MONHit ? static_cast<const MONHit *>(data()) : nullptr;
  }
  void *mutable_data() {
    return GetPointer<void *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SOURCE_NAME) &&
           verifier.VerifyString(source_name()) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE, 1) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyDataField(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

template<> inline const GEMHist *MonitorMessage::data_as<GEMHist>() const {
  return data_as_GEMHist();
}

template<> inline const GEMTrack *MonitorMessage::data_as<GEMTrack>() const {
  return data_as_GEMTrack();
}

template<> inline const MONHit *MonitorMessage::data_as<MONHit>() const {
  return data_as_MONHit();
}

struct MonitorMessageBuilder {
  typedef MonitorMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_source_name(::flatbuffers::Offset<::flatbuffers::String> source_name) {
    fbb_.AddOffset(MonitorMessage::VT_SOURCE_NAME, source_name);
  }
  void add_data_type(DataField data_type) {
    fbb_.AddElement<uint8_t>(MonitorMessage::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(::flatbuffers::Offset<void> data) {
    fbb_.AddOffset(MonitorMessage::VT_DATA, data);
  }
  explicit MonitorMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MonitorMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MonitorMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MonitorMessage> CreateMonitorMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> source_name = 0,
    DataField data_type = DataField::NONE,
    ::flatbuffers::Offset<void> data = 0) {
  MonitorMessageBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_source_name(source_name);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MonitorMessage> CreateMonitorMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *source_name = nullptr,
    DataField data_type = DataField::NONE,
    ::flatbuffers::Offset<void> data = 0) {
  auto source_name__ = source_name ? _fbb.CreateString(source_name) : 0;
  return CreateMonitorMessage(
      _fbb,
      source_name__,
      data_type,
      data);
}

inline bool VerifyDataField(::flatbuffers::Verifier &verifier, const void *obj, DataField type) {
  switch (type) {
    case DataField::NONE: {
      return true;
    }
    case DataField::GEMHist: {
      auto ptr = reinterpret_cast<const GEMHist *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataField::GEMTrack: {
      auto ptr = reinterpret_cast<const GEMTrack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataField::MONHit: {
      auto ptr = reinterpret_cast<const MONHit *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyDataFieldVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<DataField> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyDataField(
        verifier,  values->Get(i), types->GetEnum<DataField>(i))) {
      return false;
    }
  }
  return true;
}

inline const MonitorMessage *GetMonitorMessage(const void *buf) {
  return ::flatbuffers::GetRoot<MonitorMessage>(buf);
}

inline const MonitorMessage *GetSizePrefixedMonitorMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<MonitorMessage>(buf);
}

inline MonitorMessage *GetMutableMonitorMessage(void *buf) {
  return ::flatbuffers::GetMutableRoot<MonitorMessage>(buf);
}

inline MonitorMessage *GetMutableSizePrefixedMonitorMessage(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<MonitorMessage>(buf);
}

inline const char *MonitorMessageIdentifier() {
  return "mo01";
}

inline bool MonitorMessageBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, MonitorMessageIdentifier());
}

inline bool SizePrefixedMonitorMessageBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, MonitorMessageIdentifier(), true);
}

inline bool VerifyMonitorMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MonitorMessage>(MonitorMessageIdentifier());
}

inline bool VerifySizePrefixedMonitorMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<MonitorMessage>(MonitorMessageIdentifier());
}

inline void FinishMonitorMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MonitorMessage> root) {
  fbb.Finish(root, MonitorMessageIdentifier());
}

inline void FinishSizePrefixedMonitorMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MonitorMessage> root) {
  fbb.FinishSizePrefixed(root, MonitorMessageIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MO01NMX_H_
