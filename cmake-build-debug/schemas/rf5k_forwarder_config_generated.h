// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RF5KFORWARDERCONFIG_H_
#define FLATBUFFERS_GENERATED_RF5KFORWARDERCONFIG_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

struct Stream;
struct StreamBuilder;

struct ConfigUpdate;
struct ConfigUpdateBuilder;

enum class UpdateType : uint16_t {
  ADD = 0,
  REMOVE = 1,
  REMOVEALL = 2,
  MIN = ADD,
  MAX = REMOVEALL
};

inline const UpdateType (&EnumValuesUpdateType())[3] {
  static const UpdateType values[] = {
    UpdateType::ADD,
    UpdateType::REMOVE,
    UpdateType::REMOVEALL
  };
  return values;
}

inline const char * const *EnumNamesUpdateType() {
  static const char * const names[4] = {
    "ADD",
    "REMOVE",
    "REMOVEALL",
    nullptr
  };
  return names;
}

inline const char *EnumNameUpdateType(UpdateType e) {
  if (::flatbuffers::IsOutRange(e, UpdateType::ADD, UpdateType::REMOVEALL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUpdateType()[index];
}

enum class Protocol : uint16_t {
  PVA = 0,
  CA = 1,
  FAKE = 2,
  MIN = PVA,
  MAX = FAKE
};

inline const Protocol (&EnumValuesProtocol())[3] {
  static const Protocol values[] = {
    Protocol::PVA,
    Protocol::CA,
    Protocol::FAKE
  };
  return values;
}

inline const char * const *EnumNamesProtocol() {
  static const char * const names[4] = {
    "PVA",
    "CA",
    "FAKE",
    nullptr
  };
  return names;
}

inline const char *EnumNameProtocol(Protocol e) {
  if (::flatbuffers::IsOutRange(e, Protocol::PVA, Protocol::FAKE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesProtocol()[index];
}

struct Stream FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StreamBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "Stream";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHANNEL = 4,
    VT_SCHEMA = 6,
    VT_TOPIC = 8,
    VT_PROTOCOL = 10
  };
  const ::flatbuffers::String *channel() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHANNEL);
  }
  ::flatbuffers::String *mutable_channel() {
    return GetPointer<::flatbuffers::String *>(VT_CHANNEL);
  }
  const ::flatbuffers::String *schema() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SCHEMA);
  }
  ::flatbuffers::String *mutable_schema() {
    return GetPointer<::flatbuffers::String *>(VT_SCHEMA);
  }
  const ::flatbuffers::String *topic() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TOPIC);
  }
  ::flatbuffers::String *mutable_topic() {
    return GetPointer<::flatbuffers::String *>(VT_TOPIC);
  }
  Protocol protocol() const {
    return static_cast<Protocol>(GetField<uint16_t>(VT_PROTOCOL, 0));
  }
  bool mutate_protocol(Protocol _protocol = static_cast<Protocol>(0)) {
    return SetField<uint16_t>(VT_PROTOCOL, static_cast<uint16_t>(_protocol), 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHANNEL) &&
           verifier.VerifyString(channel()) &&
           VerifyOffset(verifier, VT_SCHEMA) &&
           verifier.VerifyString(schema()) &&
           VerifyOffset(verifier, VT_TOPIC) &&
           verifier.VerifyString(topic()) &&
           VerifyField<uint16_t>(verifier, VT_PROTOCOL, 2) &&
           verifier.EndTable();
  }
};

struct StreamBuilder {
  typedef Stream Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_channel(::flatbuffers::Offset<::flatbuffers::String> channel) {
    fbb_.AddOffset(Stream::VT_CHANNEL, channel);
  }
  void add_schema(::flatbuffers::Offset<::flatbuffers::String> schema) {
    fbb_.AddOffset(Stream::VT_SCHEMA, schema);
  }
  void add_topic(::flatbuffers::Offset<::flatbuffers::String> topic) {
    fbb_.AddOffset(Stream::VT_TOPIC, topic);
  }
  void add_protocol(Protocol protocol) {
    fbb_.AddElement<uint16_t>(Stream::VT_PROTOCOL, static_cast<uint16_t>(protocol), 0);
  }
  explicit StreamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Stream> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Stream>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Stream> CreateStream(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> channel = 0,
    ::flatbuffers::Offset<::flatbuffers::String> schema = 0,
    ::flatbuffers::Offset<::flatbuffers::String> topic = 0,
    Protocol protocol = Protocol::PVA) {
  StreamBuilder builder_(_fbb);
  builder_.add_topic(topic);
  builder_.add_schema(schema);
  builder_.add_channel(channel);
  builder_.add_protocol(protocol);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Stream> CreateStreamDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *channel = nullptr,
    const char *schema = nullptr,
    const char *topic = nullptr,
    Protocol protocol = Protocol::PVA) {
  auto channel__ = channel ? _fbb.CreateString(channel) : 0;
  auto schema__ = schema ? _fbb.CreateString(schema) : 0;
  auto topic__ = topic ? _fbb.CreateString(topic) : 0;
  return CreateStream(
      _fbb,
      channel__,
      schema__,
      topic__,
      protocol);
}

struct ConfigUpdate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConfigUpdateBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "ConfigUpdate";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONFIG_CHANGE = 4,
    VT_STREAMS = 6
  };
  UpdateType config_change() const {
    return static_cast<UpdateType>(GetField<uint16_t>(VT_CONFIG_CHANGE, 0));
  }
  bool mutate_config_change(UpdateType _config_change = static_cast<UpdateType>(0)) {
    return SetField<uint16_t>(VT_CONFIG_CHANGE, static_cast<uint16_t>(_config_change), 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Stream>> *streams() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Stream>> *>(VT_STREAMS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<Stream>> *mutable_streams() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<Stream>> *>(VT_STREAMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONFIG_CHANGE, 2) &&
           VerifyOffset(verifier, VT_STREAMS) &&
           verifier.VerifyVector(streams()) &&
           verifier.VerifyVectorOfTables(streams()) &&
           verifier.EndTable();
  }
};

struct ConfigUpdateBuilder {
  typedef ConfigUpdate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_config_change(UpdateType config_change) {
    fbb_.AddElement<uint16_t>(ConfigUpdate::VT_CONFIG_CHANGE, static_cast<uint16_t>(config_change), 0);
  }
  void add_streams(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Stream>>> streams) {
    fbb_.AddOffset(ConfigUpdate::VT_STREAMS, streams);
  }
  explicit ConfigUpdateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConfigUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConfigUpdate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConfigUpdate> CreateConfigUpdate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    UpdateType config_change = UpdateType::ADD,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Stream>>> streams = 0) {
  ConfigUpdateBuilder builder_(_fbb);
  builder_.add_streams(streams);
  builder_.add_config_change(config_change);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ConfigUpdate> CreateConfigUpdateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    UpdateType config_change = UpdateType::ADD,
    const std::vector<::flatbuffers::Offset<Stream>> *streams = nullptr) {
  auto streams__ = streams ? _fbb.CreateVector<::flatbuffers::Offset<Stream>>(*streams) : 0;
  return CreateConfigUpdate(
      _fbb,
      config_change,
      streams__);
}

inline const ConfigUpdate *GetConfigUpdate(const void *buf) {
  return ::flatbuffers::GetRoot<ConfigUpdate>(buf);
}

inline const ConfigUpdate *GetSizePrefixedConfigUpdate(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<ConfigUpdate>(buf);
}

inline ConfigUpdate *GetMutableConfigUpdate(void *buf) {
  return ::flatbuffers::GetMutableRoot<ConfigUpdate>(buf);
}

inline ConfigUpdate *GetMutableSizePrefixedConfigUpdate(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<ConfigUpdate>(buf);
}

inline const char *ConfigUpdateIdentifier() {
  return "rf5k";
}

inline bool ConfigUpdateBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ConfigUpdateIdentifier());
}

inline bool SizePrefixedConfigUpdateBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ConfigUpdateIdentifier(), true);
}

inline bool VerifyConfigUpdateBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ConfigUpdate>(ConfigUpdateIdentifier());
}

inline bool VerifySizePrefixedConfigUpdateBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ConfigUpdate>(ConfigUpdateIdentifier());
}

inline void FinishConfigUpdateBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ConfigUpdate> root) {
  fbb.Finish(root, ConfigUpdateIdentifier());
}

inline void FinishSizePrefixedConfigUpdateBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ConfigUpdate> root) {
  fbb.FinishSizePrefixed(root, ConfigUpdateIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_RF5KFORWARDERCONFIG_H_
