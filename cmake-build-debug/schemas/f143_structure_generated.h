// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_F143STRUCTURE_F143_STRUCTURE_H_
#define FLATBUFFERS_GENERATED_F143STRUCTURE_F143_STRUCTURE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

#include "fwdi_forwarder_internal_generated.h"

namespace f143_structure {

struct Byte;
struct ByteBuilder;

struct UByte;
struct UByteBuilder;

struct Short;
struct ShortBuilder;

struct UShort;
struct UShortBuilder;

struct Int;
struct IntBuilder;

struct UInt;
struct UIntBuilder;

struct Long;
struct LongBuilder;

struct ULong;
struct ULongBuilder;

struct Float;
struct FloatBuilder;

struct Double;
struct DoubleBuilder;

struct String;
struct StringBuilder;

struct ArrayByte;
struct ArrayByteBuilder;

struct ArrayUByte;
struct ArrayUByteBuilder;

struct ArrayShort;
struct ArrayShortBuilder;

struct ArrayUShort;
struct ArrayUShortBuilder;

struct ArrayInt;
struct ArrayIntBuilder;

struct ArrayUInt;
struct ArrayUIntBuilder;

struct ArrayLong;
struct ArrayLongBuilder;

struct ArrayULong;
struct ArrayULongBuilder;

struct ArrayFloat;
struct ArrayFloatBuilder;

struct ArrayDouble;
struct ArrayDoubleBuilder;

struct ArrayString;
struct ArrayStringBuilder;

struct ObjM;
struct ObjMBuilder;

struct Obj;
struct ObjBuilder;

struct ArrayObj;
struct ArrayObjBuilder;

struct Structure;
struct StructureBuilder;

enum class Value : uint8_t {
  NONE = 0,
  Byte = 1,
  Short = 2,
  Int = 3,
  Long = 4,
  UByte = 5,
  UShort = 6,
  UInt = 7,
  ULong = 8,
  Float = 9,
  Double = 10,
  String = 11,
  Obj = 12,
  ArrayByte = 13,
  ArrayShort = 14,
  ArrayInt = 15,
  ArrayLong = 16,
  ArrayUByte = 17,
  ArrayUShort = 18,
  ArrayUInt = 19,
  ArrayULong = 20,
  ArrayFloat = 21,
  ArrayDouble = 22,
  ArrayString = 23,
  ArrayObj = 24,
  MIN = NONE,
  MAX = ArrayObj
};

inline const Value (&EnumValuesValue())[25] {
  static const Value values[] = {
    Value::NONE,
    Value::Byte,
    Value::Short,
    Value::Int,
    Value::Long,
    Value::UByte,
    Value::UShort,
    Value::UInt,
    Value::ULong,
    Value::Float,
    Value::Double,
    Value::String,
    Value::Obj,
    Value::ArrayByte,
    Value::ArrayShort,
    Value::ArrayInt,
    Value::ArrayLong,
    Value::ArrayUByte,
    Value::ArrayUShort,
    Value::ArrayUInt,
    Value::ArrayULong,
    Value::ArrayFloat,
    Value::ArrayDouble,
    Value::ArrayString,
    Value::ArrayObj
  };
  return values;
}

inline const char * const *EnumNamesValue() {
  static const char * const names[26] = {
    "NONE",
    "Byte",
    "Short",
    "Int",
    "Long",
    "UByte",
    "UShort",
    "UInt",
    "ULong",
    "Float",
    "Double",
    "String",
    "Obj",
    "ArrayByte",
    "ArrayShort",
    "ArrayInt",
    "ArrayLong",
    "ArrayUByte",
    "ArrayUShort",
    "ArrayUInt",
    "ArrayULong",
    "ArrayFloat",
    "ArrayDouble",
    "ArrayString",
    "ArrayObj",
    nullptr
  };
  return names;
}

inline const char *EnumNameValue(Value e) {
  if (::flatbuffers::IsOutRange(e, Value::NONE, Value::ArrayObj)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesValue()[index];
}

template<typename T> struct ValueTraits {
  static const Value enum_value = Value::NONE;
};

template<> struct ValueTraits<f143_structure::Byte> {
  static const Value enum_value = Value::Byte;
};

template<> struct ValueTraits<f143_structure::Short> {
  static const Value enum_value = Value::Short;
};

template<> struct ValueTraits<f143_structure::Int> {
  static const Value enum_value = Value::Int;
};

template<> struct ValueTraits<f143_structure::Long> {
  static const Value enum_value = Value::Long;
};

template<> struct ValueTraits<f143_structure::UByte> {
  static const Value enum_value = Value::UByte;
};

template<> struct ValueTraits<f143_structure::UShort> {
  static const Value enum_value = Value::UShort;
};

template<> struct ValueTraits<f143_structure::UInt> {
  static const Value enum_value = Value::UInt;
};

template<> struct ValueTraits<f143_structure::ULong> {
  static const Value enum_value = Value::ULong;
};

template<> struct ValueTraits<f143_structure::Float> {
  static const Value enum_value = Value::Float;
};

template<> struct ValueTraits<f143_structure::Double> {
  static const Value enum_value = Value::Double;
};

template<> struct ValueTraits<f143_structure::String> {
  static const Value enum_value = Value::String;
};

template<> struct ValueTraits<f143_structure::Obj> {
  static const Value enum_value = Value::Obj;
};

template<> struct ValueTraits<f143_structure::ArrayByte> {
  static const Value enum_value = Value::ArrayByte;
};

template<> struct ValueTraits<f143_structure::ArrayShort> {
  static const Value enum_value = Value::ArrayShort;
};

template<> struct ValueTraits<f143_structure::ArrayInt> {
  static const Value enum_value = Value::ArrayInt;
};

template<> struct ValueTraits<f143_structure::ArrayLong> {
  static const Value enum_value = Value::ArrayLong;
};

template<> struct ValueTraits<f143_structure::ArrayUByte> {
  static const Value enum_value = Value::ArrayUByte;
};

template<> struct ValueTraits<f143_structure::ArrayUShort> {
  static const Value enum_value = Value::ArrayUShort;
};

template<> struct ValueTraits<f143_structure::ArrayUInt> {
  static const Value enum_value = Value::ArrayUInt;
};

template<> struct ValueTraits<f143_structure::ArrayULong> {
  static const Value enum_value = Value::ArrayULong;
};

template<> struct ValueTraits<f143_structure::ArrayFloat> {
  static const Value enum_value = Value::ArrayFloat;
};

template<> struct ValueTraits<f143_structure::ArrayDouble> {
  static const Value enum_value = Value::ArrayDouble;
};

template<> struct ValueTraits<f143_structure::ArrayString> {
  static const Value enum_value = Value::ArrayString;
};

template<> struct ValueTraits<f143_structure::ArrayObj> {
  static const Value enum_value = Value::ArrayObj;
};

bool VerifyValue(::flatbuffers::Verifier &verifier, const void *obj, Value type);
bool VerifyValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Value> *types);

struct Byte FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ByteBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "f143_structure.Byte";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int8_t value() const {
    return GetField<int8_t>(VT_VALUE, 0);
  }
  bool mutate_value(int8_t _value = 0) {
    return SetField<int8_t>(VT_VALUE, _value, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct ByteBuilder {
  typedef Byte Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int8_t value) {
    fbb_.AddElement<int8_t>(Byte::VT_VALUE, value, 0);
  }
  explicit ByteBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Byte> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Byte>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Byte> CreateByte(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int8_t value = 0) {
  ByteBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct UByte FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UByteBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "f143_structure.UByte";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint8_t value() const {
    return GetField<uint8_t>(VT_VALUE, 0);
  }
  bool mutate_value(uint8_t _value = 0) {
    return SetField<uint8_t>(VT_VALUE, _value, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct UByteBuilder {
  typedef UByte Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(uint8_t value) {
    fbb_.AddElement<uint8_t>(UByte::VT_VALUE, value, 0);
  }
  explicit UByteBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UByte> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UByte>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UByte> CreateUByte(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t value = 0) {
  UByteBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Short FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ShortBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "f143_structure.Short";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int16_t value() const {
    return GetField<int16_t>(VT_VALUE, 0);
  }
  bool mutate_value(int16_t _value = 0) {
    return SetField<int16_t>(VT_VALUE, _value, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_VALUE, 2) &&
           verifier.EndTable();
  }
};

struct ShortBuilder {
  typedef Short Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int16_t value) {
    fbb_.AddElement<int16_t>(Short::VT_VALUE, value, 0);
  }
  explicit ShortBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Short> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Short>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Short> CreateShort(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int16_t value = 0) {
  ShortBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct UShort FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UShortBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "f143_structure.UShort";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint16_t value() const {
    return GetField<uint16_t>(VT_VALUE, 0);
  }
  bool mutate_value(uint16_t _value = 0) {
    return SetField<uint16_t>(VT_VALUE, _value, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_VALUE, 2) &&
           verifier.EndTable();
  }
};

struct UShortBuilder {
  typedef UShort Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(uint16_t value) {
    fbb_.AddElement<uint16_t>(UShort::VT_VALUE, value, 0);
  }
  explicit UShortBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UShort> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UShort>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UShort> CreateUShort(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t value = 0) {
  UShortBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Int FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "f143_structure.Int";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool mutate_value(int32_t _value = 0) {
    return SetField<int32_t>(VT_VALUE, _value, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct IntBuilder {
  typedef Int Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(Int::VT_VALUE, value, 0);
  }
  explicit IntBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Int> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Int>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Int> CreateInt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0) {
  IntBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct UInt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UIntBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "f143_structure.UInt";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint32_t value() const {
    return GetField<uint32_t>(VT_VALUE, 0);
  }
  bool mutate_value(uint32_t _value = 0) {
    return SetField<uint32_t>(VT_VALUE, _value, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct UIntBuilder {
  typedef UInt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(uint32_t value) {
    fbb_.AddElement<uint32_t>(UInt::VT_VALUE, value, 0);
  }
  explicit UIntBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UInt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UInt> CreateUInt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t value = 0) {
  UIntBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Long FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LongBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "f143_structure.Long";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int64_t value() const {
    return GetField<int64_t>(VT_VALUE, 0);
  }
  bool mutate_value(int64_t _value = 0) {
    return SetField<int64_t>(VT_VALUE, _value, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct LongBuilder {
  typedef Long Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(Long::VT_VALUE, value, 0);
  }
  explicit LongBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Long> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Long>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Long> CreateLong(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t value = 0) {
  LongBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct ULong FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ULongBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "f143_structure.ULong";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint64_t value() const {
    return GetField<uint64_t>(VT_VALUE, 0);
  }
  bool mutate_value(uint64_t _value = 0) {
    return SetField<uint64_t>(VT_VALUE, _value, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct ULongBuilder {
  typedef ULong Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(uint64_t value) {
    fbb_.AddElement<uint64_t>(ULong::VT_VALUE, value, 0);
  }
  explicit ULongBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ULong> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ULong>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ULong> CreateULong(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t value = 0) {
  ULongBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Float FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FloatBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "f143_structure.Float";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool mutate_value(float _value = 0.0f) {
    return SetField<float>(VT_VALUE, _value, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct FloatBuilder {
  typedef Float Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(Float::VT_VALUE, value, 0.0f);
  }
  explicit FloatBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Float> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Float>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Float> CreateFloat(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f) {
  FloatBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Double FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DoubleBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "f143_structure.Double";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  bool mutate_value(double _value = 0.0) {
    return SetField<double>(VT_VALUE, _value, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct DoubleBuilder {
  typedef Double Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(double value) {
    fbb_.AddElement<double>(Double::VT_VALUE, value, 0.0);
  }
  explicit DoubleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Double> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Double>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Double> CreateDouble(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double value = 0.0) {
  DoubleBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct String FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StringBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "f143_structure.String";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  ::flatbuffers::String *mutable_value() {
    return GetPointer<::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct StringBuilder {
  typedef String Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(String::VT_VALUE, value);
  }
  explicit StringBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<String> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<String>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<String> CreateString(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  StringBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<String> CreateStringDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return f143_structure::CreateString(
      _fbb,
      value__);
}

struct ArrayByte FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArrayByteBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "f143_structure.ArrayByte";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::Vector<int8_t> *value() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_VALUE);
  }
  ::flatbuffers::Vector<int8_t> *mutable_value() {
    return GetPointer<::flatbuffers::Vector<int8_t> *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct ArrayByteBuilder {
  typedef ArrayByte Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> value) {
    fbb_.AddOffset(ArrayByte::VT_VALUE, value);
  }
  explicit ArrayByteBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArrayByte> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArrayByte>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArrayByte> CreateArrayByte(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> value = 0) {
  ArrayByteBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ArrayByte> CreateArrayByteDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<int8_t>(*value) : 0;
  return f143_structure::CreateArrayByte(
      _fbb,
      value__);
}

struct ArrayUByte FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArrayUByteBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "f143_structure.ArrayUByte";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_value() {
    return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct ArrayUByteBuilder {
  typedef ArrayUByte Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(ArrayUByte::VT_VALUE, value);
  }
  explicit ArrayUByteBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArrayUByte> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArrayUByte>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArrayUByte> CreateArrayUByte(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> value = 0) {
  ArrayUByteBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ArrayUByte> CreateArrayUByteDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<uint8_t>(*value) : 0;
  return f143_structure::CreateArrayUByte(
      _fbb,
      value__);
}

struct ArrayShort FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArrayShortBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "f143_structure.ArrayShort";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::Vector<int16_t> *value() const {
    return GetPointer<const ::flatbuffers::Vector<int16_t> *>(VT_VALUE);
  }
  ::flatbuffers::Vector<int16_t> *mutable_value() {
    return GetPointer<::flatbuffers::Vector<int16_t> *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct ArrayShortBuilder {
  typedef ArrayShort Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<int16_t>> value) {
    fbb_.AddOffset(ArrayShort::VT_VALUE, value);
  }
  explicit ArrayShortBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArrayShort> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArrayShort>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArrayShort> CreateArrayShort(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int16_t>> value = 0) {
  ArrayShortBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ArrayShort> CreateArrayShortDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int16_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<int16_t>(*value) : 0;
  return f143_structure::CreateArrayShort(
      _fbb,
      value__);
}

struct ArrayUShort FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArrayUShortBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "f143_structure.ArrayUShort";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::Vector<uint16_t> *value() const {
    return GetPointer<const ::flatbuffers::Vector<uint16_t> *>(VT_VALUE);
  }
  ::flatbuffers::Vector<uint16_t> *mutable_value() {
    return GetPointer<::flatbuffers::Vector<uint16_t> *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct ArrayUShortBuilder {
  typedef ArrayUShort Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> value) {
    fbb_.AddOffset(ArrayUShort::VT_VALUE, value);
  }
  explicit ArrayUShortBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArrayUShort> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArrayUShort>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArrayUShort> CreateArrayUShort(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> value = 0) {
  ArrayUShortBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ArrayUShort> CreateArrayUShortDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint16_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<uint16_t>(*value) : 0;
  return f143_structure::CreateArrayUShort(
      _fbb,
      value__);
}

struct ArrayInt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArrayIntBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "f143_structure.ArrayInt";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::Vector<int32_t> *value() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_VALUE);
  }
  ::flatbuffers::Vector<int32_t> *mutable_value() {
    return GetPointer<::flatbuffers::Vector<int32_t> *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct ArrayIntBuilder {
  typedef ArrayInt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> value) {
    fbb_.AddOffset(ArrayInt::VT_VALUE, value);
  }
  explicit ArrayIntBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArrayInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArrayInt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArrayInt> CreateArrayInt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> value = 0) {
  ArrayIntBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ArrayInt> CreateArrayIntDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<int32_t>(*value) : 0;
  return f143_structure::CreateArrayInt(
      _fbb,
      value__);
}

struct ArrayUInt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArrayUIntBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "f143_structure.ArrayUInt";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::Vector<uint32_t> *value() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_VALUE);
  }
  ::flatbuffers::Vector<uint32_t> *mutable_value() {
    return GetPointer<::flatbuffers::Vector<uint32_t> *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct ArrayUIntBuilder {
  typedef ArrayUInt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> value) {
    fbb_.AddOffset(ArrayUInt::VT_VALUE, value);
  }
  explicit ArrayUIntBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArrayUInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArrayUInt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArrayUInt> CreateArrayUInt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> value = 0) {
  ArrayUIntBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ArrayUInt> CreateArrayUIntDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<uint32_t>(*value) : 0;
  return f143_structure::CreateArrayUInt(
      _fbb,
      value__);
}

struct ArrayLong FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArrayLongBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "f143_structure.ArrayLong";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::Vector<int64_t> *value() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_VALUE);
  }
  ::flatbuffers::Vector<int64_t> *mutable_value() {
    return GetPointer<::flatbuffers::Vector<int64_t> *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct ArrayLongBuilder {
  typedef ArrayLong Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> value) {
    fbb_.AddOffset(ArrayLong::VT_VALUE, value);
  }
  explicit ArrayLongBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArrayLong> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArrayLong>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArrayLong> CreateArrayLong(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> value = 0) {
  ArrayLongBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ArrayLong> CreateArrayLongDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<int64_t>(*value) : 0;
  return f143_structure::CreateArrayLong(
      _fbb,
      value__);
}

struct ArrayULong FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArrayULongBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "f143_structure.ArrayULong";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::Vector<uint64_t> *value() const {
    return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_VALUE);
  }
  ::flatbuffers::Vector<uint64_t> *mutable_value() {
    return GetPointer<::flatbuffers::Vector<uint64_t> *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct ArrayULongBuilder {
  typedef ArrayULong Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> value) {
    fbb_.AddOffset(ArrayULong::VT_VALUE, value);
  }
  explicit ArrayULongBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArrayULong> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArrayULong>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArrayULong> CreateArrayULong(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> value = 0) {
  ArrayULongBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ArrayULong> CreateArrayULongDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint64_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<uint64_t>(*value) : 0;
  return f143_structure::CreateArrayULong(
      _fbb,
      value__);
}

struct ArrayFloat FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArrayFloatBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "f143_structure.ArrayFloat";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::Vector<float> *value() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_VALUE);
  }
  ::flatbuffers::Vector<float> *mutable_value() {
    return GetPointer<::flatbuffers::Vector<float> *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct ArrayFloatBuilder {
  typedef ArrayFloat Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<float>> value) {
    fbb_.AddOffset(ArrayFloat::VT_VALUE, value);
  }
  explicit ArrayFloatBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArrayFloat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArrayFloat>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArrayFloat> CreateArrayFloat(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> value = 0) {
  ArrayFloatBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ArrayFloat> CreateArrayFloatDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<float>(*value) : 0;
  return f143_structure::CreateArrayFloat(
      _fbb,
      value__);
}

struct ArrayDouble FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArrayDoubleBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "f143_structure.ArrayDouble";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::Vector<double> *value() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_VALUE);
  }
  ::flatbuffers::Vector<double> *mutable_value() {
    return GetPointer<::flatbuffers::Vector<double> *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct ArrayDoubleBuilder {
  typedef ArrayDouble Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<double>> value) {
    fbb_.AddOffset(ArrayDouble::VT_VALUE, value);
  }
  explicit ArrayDoubleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArrayDouble> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArrayDouble>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArrayDouble> CreateArrayDouble(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> value = 0) {
  ArrayDoubleBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ArrayDouble> CreateArrayDoubleDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<double>(*value) : 0;
  return f143_structure::CreateArrayDouble(
      _fbb,
      value__);
}

struct ArrayString FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArrayStringBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "f143_structure.ArrayString";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *value() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_VALUE);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_value() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.VerifyVectorOfStrings(value()) &&
           verifier.EndTable();
  }
};

struct ArrayStringBuilder {
  typedef ArrayString Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> value) {
    fbb_.AddOffset(ArrayString::VT_VALUE, value);
  }
  explicit ArrayStringBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArrayString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArrayString>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArrayString> CreateArrayString(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> value = 0) {
  ArrayStringBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ArrayString> CreateArrayStringDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*value) : 0;
  return f143_structure::CreateArrayString(
      _fbb,
      value__);
}

struct ObjM FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjMBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "f143_structure.ObjM";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_K = 4,
    VT_V_TYPE = 6,
    VT_V = 8
  };
  const ::flatbuffers::String *k() const {
    return GetPointer<const ::flatbuffers::String *>(VT_K);
  }
  ::flatbuffers::String *mutable_k() {
    return GetPointer<::flatbuffers::String *>(VT_K);
  }
  f143_structure::Value v_type() const {
    return static_cast<f143_structure::Value>(GetField<uint8_t>(VT_V_TYPE, 0));
  }
  const void *v() const {
    return GetPointer<const void *>(VT_V);
  }
  template<typename T> const T *v_as() const;
  const f143_structure::Byte *v_as_Byte() const {
    return v_type() == f143_structure::Value::Byte ? static_cast<const f143_structure::Byte *>(v()) : nullptr;
  }
  const f143_structure::Short *v_as_Short() const {
    return v_type() == f143_structure::Value::Short ? static_cast<const f143_structure::Short *>(v()) : nullptr;
  }
  const f143_structure::Int *v_as_Int() const {
    return v_type() == f143_structure::Value::Int ? static_cast<const f143_structure::Int *>(v()) : nullptr;
  }
  const f143_structure::Long *v_as_Long() const {
    return v_type() == f143_structure::Value::Long ? static_cast<const f143_structure::Long *>(v()) : nullptr;
  }
  const f143_structure::UByte *v_as_UByte() const {
    return v_type() == f143_structure::Value::UByte ? static_cast<const f143_structure::UByte *>(v()) : nullptr;
  }
  const f143_structure::UShort *v_as_UShort() const {
    return v_type() == f143_structure::Value::UShort ? static_cast<const f143_structure::UShort *>(v()) : nullptr;
  }
  const f143_structure::UInt *v_as_UInt() const {
    return v_type() == f143_structure::Value::UInt ? static_cast<const f143_structure::UInt *>(v()) : nullptr;
  }
  const f143_structure::ULong *v_as_ULong() const {
    return v_type() == f143_structure::Value::ULong ? static_cast<const f143_structure::ULong *>(v()) : nullptr;
  }
  const f143_structure::Float *v_as_Float() const {
    return v_type() == f143_structure::Value::Float ? static_cast<const f143_structure::Float *>(v()) : nullptr;
  }
  const f143_structure::Double *v_as_Double() const {
    return v_type() == f143_structure::Value::Double ? static_cast<const f143_structure::Double *>(v()) : nullptr;
  }
  const f143_structure::String *v_as_String() const {
    return v_type() == f143_structure::Value::String ? static_cast<const f143_structure::String *>(v()) : nullptr;
  }
  const f143_structure::Obj *v_as_Obj() const {
    return v_type() == f143_structure::Value::Obj ? static_cast<const f143_structure::Obj *>(v()) : nullptr;
  }
  const f143_structure::ArrayByte *v_as_ArrayByte() const {
    return v_type() == f143_structure::Value::ArrayByte ? static_cast<const f143_structure::ArrayByte *>(v()) : nullptr;
  }
  const f143_structure::ArrayShort *v_as_ArrayShort() const {
    return v_type() == f143_structure::Value::ArrayShort ? static_cast<const f143_structure::ArrayShort *>(v()) : nullptr;
  }
  const f143_structure::ArrayInt *v_as_ArrayInt() const {
    return v_type() == f143_structure::Value::ArrayInt ? static_cast<const f143_structure::ArrayInt *>(v()) : nullptr;
  }
  const f143_structure::ArrayLong *v_as_ArrayLong() const {
    return v_type() == f143_structure::Value::ArrayLong ? static_cast<const f143_structure::ArrayLong *>(v()) : nullptr;
  }
  const f143_structure::ArrayUByte *v_as_ArrayUByte() const {
    return v_type() == f143_structure::Value::ArrayUByte ? static_cast<const f143_structure::ArrayUByte *>(v()) : nullptr;
  }
  const f143_structure::ArrayUShort *v_as_ArrayUShort() const {
    return v_type() == f143_structure::Value::ArrayUShort ? static_cast<const f143_structure::ArrayUShort *>(v()) : nullptr;
  }
  const f143_structure::ArrayUInt *v_as_ArrayUInt() const {
    return v_type() == f143_structure::Value::ArrayUInt ? static_cast<const f143_structure::ArrayUInt *>(v()) : nullptr;
  }
  const f143_structure::ArrayULong *v_as_ArrayULong() const {
    return v_type() == f143_structure::Value::ArrayULong ? static_cast<const f143_structure::ArrayULong *>(v()) : nullptr;
  }
  const f143_structure::ArrayFloat *v_as_ArrayFloat() const {
    return v_type() == f143_structure::Value::ArrayFloat ? static_cast<const f143_structure::ArrayFloat *>(v()) : nullptr;
  }
  const f143_structure::ArrayDouble *v_as_ArrayDouble() const {
    return v_type() == f143_structure::Value::ArrayDouble ? static_cast<const f143_structure::ArrayDouble *>(v()) : nullptr;
  }
  const f143_structure::ArrayString *v_as_ArrayString() const {
    return v_type() == f143_structure::Value::ArrayString ? static_cast<const f143_structure::ArrayString *>(v()) : nullptr;
  }
  const f143_structure::ArrayObj *v_as_ArrayObj() const {
    return v_type() == f143_structure::Value::ArrayObj ? static_cast<const f143_structure::ArrayObj *>(v()) : nullptr;
  }
  void *mutable_v() {
    return GetPointer<void *>(VT_V);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_K) &&
           verifier.VerifyString(k()) &&
           VerifyField<uint8_t>(verifier, VT_V_TYPE, 1) &&
           VerifyOffset(verifier, VT_V) &&
           VerifyValue(verifier, v(), v_type()) &&
           verifier.EndTable();
  }
};

template<> inline const f143_structure::Byte *ObjM::v_as<f143_structure::Byte>() const {
  return v_as_Byte();
}

template<> inline const f143_structure::Short *ObjM::v_as<f143_structure::Short>() const {
  return v_as_Short();
}

template<> inline const f143_structure::Int *ObjM::v_as<f143_structure::Int>() const {
  return v_as_Int();
}

template<> inline const f143_structure::Long *ObjM::v_as<f143_structure::Long>() const {
  return v_as_Long();
}

template<> inline const f143_structure::UByte *ObjM::v_as<f143_structure::UByte>() const {
  return v_as_UByte();
}

template<> inline const f143_structure::UShort *ObjM::v_as<f143_structure::UShort>() const {
  return v_as_UShort();
}

template<> inline const f143_structure::UInt *ObjM::v_as<f143_structure::UInt>() const {
  return v_as_UInt();
}

template<> inline const f143_structure::ULong *ObjM::v_as<f143_structure::ULong>() const {
  return v_as_ULong();
}

template<> inline const f143_structure::Float *ObjM::v_as<f143_structure::Float>() const {
  return v_as_Float();
}

template<> inline const f143_structure::Double *ObjM::v_as<f143_structure::Double>() const {
  return v_as_Double();
}

template<> inline const f143_structure::String *ObjM::v_as<f143_structure::String>() const {
  return v_as_String();
}

template<> inline const f143_structure::Obj *ObjM::v_as<f143_structure::Obj>() const {
  return v_as_Obj();
}

template<> inline const f143_structure::ArrayByte *ObjM::v_as<f143_structure::ArrayByte>() const {
  return v_as_ArrayByte();
}

template<> inline const f143_structure::ArrayShort *ObjM::v_as<f143_structure::ArrayShort>() const {
  return v_as_ArrayShort();
}

template<> inline const f143_structure::ArrayInt *ObjM::v_as<f143_structure::ArrayInt>() const {
  return v_as_ArrayInt();
}

template<> inline const f143_structure::ArrayLong *ObjM::v_as<f143_structure::ArrayLong>() const {
  return v_as_ArrayLong();
}

template<> inline const f143_structure::ArrayUByte *ObjM::v_as<f143_structure::ArrayUByte>() const {
  return v_as_ArrayUByte();
}

template<> inline const f143_structure::ArrayUShort *ObjM::v_as<f143_structure::ArrayUShort>() const {
  return v_as_ArrayUShort();
}

template<> inline const f143_structure::ArrayUInt *ObjM::v_as<f143_structure::ArrayUInt>() const {
  return v_as_ArrayUInt();
}

template<> inline const f143_structure::ArrayULong *ObjM::v_as<f143_structure::ArrayULong>() const {
  return v_as_ArrayULong();
}

template<> inline const f143_structure::ArrayFloat *ObjM::v_as<f143_structure::ArrayFloat>() const {
  return v_as_ArrayFloat();
}

template<> inline const f143_structure::ArrayDouble *ObjM::v_as<f143_structure::ArrayDouble>() const {
  return v_as_ArrayDouble();
}

template<> inline const f143_structure::ArrayString *ObjM::v_as<f143_structure::ArrayString>() const {
  return v_as_ArrayString();
}

template<> inline const f143_structure::ArrayObj *ObjM::v_as<f143_structure::ArrayObj>() const {
  return v_as_ArrayObj();
}

struct ObjMBuilder {
  typedef ObjM Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_k(::flatbuffers::Offset<::flatbuffers::String> k) {
    fbb_.AddOffset(ObjM::VT_K, k);
  }
  void add_v_type(f143_structure::Value v_type) {
    fbb_.AddElement<uint8_t>(ObjM::VT_V_TYPE, static_cast<uint8_t>(v_type), 0);
  }
  void add_v(::flatbuffers::Offset<void> v) {
    fbb_.AddOffset(ObjM::VT_V, v);
  }
  explicit ObjMBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObjM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObjM>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ObjM> CreateObjM(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> k = 0,
    f143_structure::Value v_type = f143_structure::Value::NONE,
    ::flatbuffers::Offset<void> v = 0) {
  ObjMBuilder builder_(_fbb);
  builder_.add_v(v);
  builder_.add_k(k);
  builder_.add_v_type(v_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ObjM> CreateObjMDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *k = nullptr,
    f143_structure::Value v_type = f143_structure::Value::NONE,
    ::flatbuffers::Offset<void> v = 0) {
  auto k__ = k ? _fbb.CreateString(k) : 0;
  return f143_structure::CreateObjM(
      _fbb,
      k__,
      v_type,
      v);
}

struct Obj FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "f143_structure.Obj";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<f143_structure::ObjM>> *value() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<f143_structure::ObjM>> *>(VT_VALUE);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<f143_structure::ObjM>> *mutable_value() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<f143_structure::ObjM>> *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.VerifyVectorOfTables(value()) &&
           verifier.EndTable();
  }
};

struct ObjBuilder {
  typedef Obj Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<f143_structure::ObjM>>> value) {
    fbb_.AddOffset(Obj::VT_VALUE, value);
  }
  explicit ObjBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Obj> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Obj>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Obj> CreateObj(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<f143_structure::ObjM>>> value = 0) {
  ObjBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Obj> CreateObjDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<f143_structure::ObjM>> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<::flatbuffers::Offset<f143_structure::ObjM>>(*value) : 0;
  return f143_structure::CreateObj(
      _fbb,
      value__);
}

struct ArrayObj FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArrayObjBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "f143_structure.ArrayObj";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<f143_structure::Obj>> *value() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<f143_structure::Obj>> *>(VT_VALUE);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<f143_structure::Obj>> *mutable_value() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<f143_structure::Obj>> *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.VerifyVectorOfTables(value()) &&
           verifier.EndTable();
  }
};

struct ArrayObjBuilder {
  typedef ArrayObj Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<f143_structure::Obj>>> value) {
    fbb_.AddOffset(ArrayObj::VT_VALUE, value);
  }
  explicit ArrayObjBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArrayObj> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArrayObj>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArrayObj> CreateArrayObj(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<f143_structure::Obj>>> value = 0) {
  ArrayObjBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ArrayObj> CreateArrayObjDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<f143_structure::Obj>> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<::flatbuffers::Offset<f143_structure::Obj>>(*value) : 0;
  return f143_structure::CreateArrayObj(
      _fbb,
      value__);
}

struct Structure FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StructureBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "f143_structure.Structure";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8,
    VT_TIMESTAMP = 10,
    VT_FWDINFO_TYPE = 12,
    VT_FWDINFO = 14
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  f143_structure::Value value_type() const {
    return static_cast<f143_structure::Value>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const f143_structure::Byte *value_as_Byte() const {
    return value_type() == f143_structure::Value::Byte ? static_cast<const f143_structure::Byte *>(value()) : nullptr;
  }
  const f143_structure::Short *value_as_Short() const {
    return value_type() == f143_structure::Value::Short ? static_cast<const f143_structure::Short *>(value()) : nullptr;
  }
  const f143_structure::Int *value_as_Int() const {
    return value_type() == f143_structure::Value::Int ? static_cast<const f143_structure::Int *>(value()) : nullptr;
  }
  const f143_structure::Long *value_as_Long() const {
    return value_type() == f143_structure::Value::Long ? static_cast<const f143_structure::Long *>(value()) : nullptr;
  }
  const f143_structure::UByte *value_as_UByte() const {
    return value_type() == f143_structure::Value::UByte ? static_cast<const f143_structure::UByte *>(value()) : nullptr;
  }
  const f143_structure::UShort *value_as_UShort() const {
    return value_type() == f143_structure::Value::UShort ? static_cast<const f143_structure::UShort *>(value()) : nullptr;
  }
  const f143_structure::UInt *value_as_UInt() const {
    return value_type() == f143_structure::Value::UInt ? static_cast<const f143_structure::UInt *>(value()) : nullptr;
  }
  const f143_structure::ULong *value_as_ULong() const {
    return value_type() == f143_structure::Value::ULong ? static_cast<const f143_structure::ULong *>(value()) : nullptr;
  }
  const f143_structure::Float *value_as_Float() const {
    return value_type() == f143_structure::Value::Float ? static_cast<const f143_structure::Float *>(value()) : nullptr;
  }
  const f143_structure::Double *value_as_Double() const {
    return value_type() == f143_structure::Value::Double ? static_cast<const f143_structure::Double *>(value()) : nullptr;
  }
  const f143_structure::String *value_as_String() const {
    return value_type() == f143_structure::Value::String ? static_cast<const f143_structure::String *>(value()) : nullptr;
  }
  const f143_structure::Obj *value_as_Obj() const {
    return value_type() == f143_structure::Value::Obj ? static_cast<const f143_structure::Obj *>(value()) : nullptr;
  }
  const f143_structure::ArrayByte *value_as_ArrayByte() const {
    return value_type() == f143_structure::Value::ArrayByte ? static_cast<const f143_structure::ArrayByte *>(value()) : nullptr;
  }
  const f143_structure::ArrayShort *value_as_ArrayShort() const {
    return value_type() == f143_structure::Value::ArrayShort ? static_cast<const f143_structure::ArrayShort *>(value()) : nullptr;
  }
  const f143_structure::ArrayInt *value_as_ArrayInt() const {
    return value_type() == f143_structure::Value::ArrayInt ? static_cast<const f143_structure::ArrayInt *>(value()) : nullptr;
  }
  const f143_structure::ArrayLong *value_as_ArrayLong() const {
    return value_type() == f143_structure::Value::ArrayLong ? static_cast<const f143_structure::ArrayLong *>(value()) : nullptr;
  }
  const f143_structure::ArrayUByte *value_as_ArrayUByte() const {
    return value_type() == f143_structure::Value::ArrayUByte ? static_cast<const f143_structure::ArrayUByte *>(value()) : nullptr;
  }
  const f143_structure::ArrayUShort *value_as_ArrayUShort() const {
    return value_type() == f143_structure::Value::ArrayUShort ? static_cast<const f143_structure::ArrayUShort *>(value()) : nullptr;
  }
  const f143_structure::ArrayUInt *value_as_ArrayUInt() const {
    return value_type() == f143_structure::Value::ArrayUInt ? static_cast<const f143_structure::ArrayUInt *>(value()) : nullptr;
  }
  const f143_structure::ArrayULong *value_as_ArrayULong() const {
    return value_type() == f143_structure::Value::ArrayULong ? static_cast<const f143_structure::ArrayULong *>(value()) : nullptr;
  }
  const f143_structure::ArrayFloat *value_as_ArrayFloat() const {
    return value_type() == f143_structure::Value::ArrayFloat ? static_cast<const f143_structure::ArrayFloat *>(value()) : nullptr;
  }
  const f143_structure::ArrayDouble *value_as_ArrayDouble() const {
    return value_type() == f143_structure::Value::ArrayDouble ? static_cast<const f143_structure::ArrayDouble *>(value()) : nullptr;
  }
  const f143_structure::ArrayString *value_as_ArrayString() const {
    return value_type() == f143_structure::Value::ArrayString ? static_cast<const f143_structure::ArrayString *>(value()) : nullptr;
  }
  const f143_structure::ArrayObj *value_as_ArrayObj() const {
    return value_type() == f143_structure::Value::ArrayObj ? static_cast<const f143_structure::ArrayObj *>(value()) : nullptr;
  }
  void *mutable_value() {
    return GetPointer<void *>(VT_VALUE);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool mutate_timestamp(uint64_t _timestamp = 0) {
    return SetField<uint64_t>(VT_TIMESTAMP, _timestamp, 0);
  }
  forwarder_internal fwdinfo_type() const {
    return static_cast<forwarder_internal>(GetField<uint8_t>(VT_FWDINFO_TYPE, 0));
  }
  const void *fwdinfo() const {
    return GetPointer<const void *>(VT_FWDINFO);
  }
  template<typename T> const T *fwdinfo_as() const;
  const fwdinfo_1_t *fwdinfo_as_fwdinfo_1_t() const {
    return fwdinfo_type() == forwarder_internal::fwdinfo_1_t ? static_cast<const fwdinfo_1_t *>(fwdinfo()) : nullptr;
  }
  void *mutable_fwdinfo() {
    return GetPointer<void *>(VT_FWDINFO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyValue(verifier, value(), value_type()) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           VerifyField<uint8_t>(verifier, VT_FWDINFO_TYPE, 1) &&
           VerifyOffset(verifier, VT_FWDINFO) &&
           Verifyforwarder_internal(verifier, fwdinfo(), fwdinfo_type()) &&
           verifier.EndTable();
  }
};

template<> inline const f143_structure::Byte *Structure::value_as<f143_structure::Byte>() const {
  return value_as_Byte();
}

template<> inline const f143_structure::Short *Structure::value_as<f143_structure::Short>() const {
  return value_as_Short();
}

template<> inline const f143_structure::Int *Structure::value_as<f143_structure::Int>() const {
  return value_as_Int();
}

template<> inline const f143_structure::Long *Structure::value_as<f143_structure::Long>() const {
  return value_as_Long();
}

template<> inline const f143_structure::UByte *Structure::value_as<f143_structure::UByte>() const {
  return value_as_UByte();
}

template<> inline const f143_structure::UShort *Structure::value_as<f143_structure::UShort>() const {
  return value_as_UShort();
}

template<> inline const f143_structure::UInt *Structure::value_as<f143_structure::UInt>() const {
  return value_as_UInt();
}

template<> inline const f143_structure::ULong *Structure::value_as<f143_structure::ULong>() const {
  return value_as_ULong();
}

template<> inline const f143_structure::Float *Structure::value_as<f143_structure::Float>() const {
  return value_as_Float();
}

template<> inline const f143_structure::Double *Structure::value_as<f143_structure::Double>() const {
  return value_as_Double();
}

template<> inline const f143_structure::String *Structure::value_as<f143_structure::String>() const {
  return value_as_String();
}

template<> inline const f143_structure::Obj *Structure::value_as<f143_structure::Obj>() const {
  return value_as_Obj();
}

template<> inline const f143_structure::ArrayByte *Structure::value_as<f143_structure::ArrayByte>() const {
  return value_as_ArrayByte();
}

template<> inline const f143_structure::ArrayShort *Structure::value_as<f143_structure::ArrayShort>() const {
  return value_as_ArrayShort();
}

template<> inline const f143_structure::ArrayInt *Structure::value_as<f143_structure::ArrayInt>() const {
  return value_as_ArrayInt();
}

template<> inline const f143_structure::ArrayLong *Structure::value_as<f143_structure::ArrayLong>() const {
  return value_as_ArrayLong();
}

template<> inline const f143_structure::ArrayUByte *Structure::value_as<f143_structure::ArrayUByte>() const {
  return value_as_ArrayUByte();
}

template<> inline const f143_structure::ArrayUShort *Structure::value_as<f143_structure::ArrayUShort>() const {
  return value_as_ArrayUShort();
}

template<> inline const f143_structure::ArrayUInt *Structure::value_as<f143_structure::ArrayUInt>() const {
  return value_as_ArrayUInt();
}

template<> inline const f143_structure::ArrayULong *Structure::value_as<f143_structure::ArrayULong>() const {
  return value_as_ArrayULong();
}

template<> inline const f143_structure::ArrayFloat *Structure::value_as<f143_structure::ArrayFloat>() const {
  return value_as_ArrayFloat();
}

template<> inline const f143_structure::ArrayDouble *Structure::value_as<f143_structure::ArrayDouble>() const {
  return value_as_ArrayDouble();
}

template<> inline const f143_structure::ArrayString *Structure::value_as<f143_structure::ArrayString>() const {
  return value_as_ArrayString();
}

template<> inline const f143_structure::ArrayObj *Structure::value_as<f143_structure::ArrayObj>() const {
  return value_as_ArrayObj();
}

template<> inline const fwdinfo_1_t *Structure::fwdinfo_as<fwdinfo_1_t>() const {
  return fwdinfo_as_fwdinfo_1_t();
}

struct StructureBuilder {
  typedef Structure Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Structure::VT_NAME, name);
  }
  void add_value_type(f143_structure::Value value_type) {
    fbb_.AddElement<uint8_t>(Structure::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(Structure::VT_VALUE, value);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(Structure::VT_TIMESTAMP, timestamp, 0);
  }
  void add_fwdinfo_type(forwarder_internal fwdinfo_type) {
    fbb_.AddElement<uint8_t>(Structure::VT_FWDINFO_TYPE, static_cast<uint8_t>(fwdinfo_type), 0);
  }
  void add_fwdinfo(::flatbuffers::Offset<void> fwdinfo) {
    fbb_.AddOffset(Structure::VT_FWDINFO, fwdinfo);
  }
  explicit StructureBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Structure> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Structure>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Structure> CreateStructure(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    f143_structure::Value value_type = f143_structure::Value::NONE,
    ::flatbuffers::Offset<void> value = 0,
    uint64_t timestamp = 0,
    forwarder_internal fwdinfo_type = forwarder_internal::NONE,
    ::flatbuffers::Offset<void> fwdinfo = 0) {
  StructureBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_fwdinfo(fwdinfo);
  builder_.add_value(value);
  builder_.add_name(name);
  builder_.add_fwdinfo_type(fwdinfo_type);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Structure> CreateStructureDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    f143_structure::Value value_type = f143_structure::Value::NONE,
    ::flatbuffers::Offset<void> value = 0,
    uint64_t timestamp = 0,
    forwarder_internal fwdinfo_type = forwarder_internal::NONE,
    ::flatbuffers::Offset<void> fwdinfo = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return f143_structure::CreateStructure(
      _fbb,
      name__,
      value_type,
      value,
      timestamp,
      fwdinfo_type,
      fwdinfo);
}

inline bool VerifyValue(::flatbuffers::Verifier &verifier, const void *obj, Value type) {
  switch (type) {
    case Value::NONE: {
      return true;
    }
    case Value::Byte: {
      auto ptr = reinterpret_cast<const f143_structure::Byte *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::Short: {
      auto ptr = reinterpret_cast<const f143_structure::Short *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::Int: {
      auto ptr = reinterpret_cast<const f143_structure::Int *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::Long: {
      auto ptr = reinterpret_cast<const f143_structure::Long *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::UByte: {
      auto ptr = reinterpret_cast<const f143_structure::UByte *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::UShort: {
      auto ptr = reinterpret_cast<const f143_structure::UShort *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::UInt: {
      auto ptr = reinterpret_cast<const f143_structure::UInt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::ULong: {
      auto ptr = reinterpret_cast<const f143_structure::ULong *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::Float: {
      auto ptr = reinterpret_cast<const f143_structure::Float *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::Double: {
      auto ptr = reinterpret_cast<const f143_structure::Double *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::String: {
      auto ptr = reinterpret_cast<const f143_structure::String *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::Obj: {
      auto ptr = reinterpret_cast<const f143_structure::Obj *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::ArrayByte: {
      auto ptr = reinterpret_cast<const f143_structure::ArrayByte *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::ArrayShort: {
      auto ptr = reinterpret_cast<const f143_structure::ArrayShort *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::ArrayInt: {
      auto ptr = reinterpret_cast<const f143_structure::ArrayInt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::ArrayLong: {
      auto ptr = reinterpret_cast<const f143_structure::ArrayLong *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::ArrayUByte: {
      auto ptr = reinterpret_cast<const f143_structure::ArrayUByte *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::ArrayUShort: {
      auto ptr = reinterpret_cast<const f143_structure::ArrayUShort *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::ArrayUInt: {
      auto ptr = reinterpret_cast<const f143_structure::ArrayUInt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::ArrayULong: {
      auto ptr = reinterpret_cast<const f143_structure::ArrayULong *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::ArrayFloat: {
      auto ptr = reinterpret_cast<const f143_structure::ArrayFloat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::ArrayDouble: {
      auto ptr = reinterpret_cast<const f143_structure::ArrayDouble *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::ArrayString: {
      auto ptr = reinterpret_cast<const f143_structure::ArrayString *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::ArrayObj: {
      auto ptr = reinterpret_cast<const f143_structure::ArrayObj *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Value> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyValue(
        verifier,  values->Get(i), types->GetEnum<Value>(i))) {
      return false;
    }
  }
  return true;
}

inline const f143_structure::Structure *GetStructure(const void *buf) {
  return ::flatbuffers::GetRoot<f143_structure::Structure>(buf);
}

inline const f143_structure::Structure *GetSizePrefixedStructure(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<f143_structure::Structure>(buf);
}

inline Structure *GetMutableStructure(void *buf) {
  return ::flatbuffers::GetMutableRoot<Structure>(buf);
}

inline f143_structure::Structure *GetMutableSizePrefixedStructure(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<f143_structure::Structure>(buf);
}

inline const char *StructureIdentifier() {
  return "f143";
}

inline bool StructureBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, StructureIdentifier());
}

inline bool SizePrefixedStructureBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, StructureIdentifier(), true);
}

inline bool VerifyStructureBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<f143_structure::Structure>(StructureIdentifier());
}

inline bool VerifySizePrefixedStructureBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<f143_structure::Structure>(StructureIdentifier());
}

inline void FinishStructureBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<f143_structure::Structure> root) {
  fbb.Finish(root, StructureIdentifier());
}

inline void FinishSizePrefixedStructureBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<f143_structure::Structure> root) {
  fbb.FinishSizePrefixed(root, StructureIdentifier());
}

}  // namespace f143_structure

#endif  // FLATBUFFERS_GENERATED_F143STRUCTURE_F143_STRUCTURE_H_
