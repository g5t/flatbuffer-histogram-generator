// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DTDBADCPULSEDEBUG_H_
#define FLATBUFFERS_GENERATED_DTDBADCPULSEDEBUG_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

struct AdcPulseDebug;
struct AdcPulseDebugBuilder;

struct AdcPulseDebug FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AdcPulseDebugBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "AdcPulseDebug";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AMPLITUDE = 4,
    VT_PEAK_AREA = 6,
    VT_BACKGROUND = 8,
    VT_THRESHOLD_TIME = 10,
    VT_PEAK_TIME = 12
  };
  const ::flatbuffers::Vector<uint32_t> *amplitude() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_AMPLITUDE);
  }
  ::flatbuffers::Vector<uint32_t> *mutable_amplitude() {
    return GetPointer<::flatbuffers::Vector<uint32_t> *>(VT_AMPLITUDE);
  }
  const ::flatbuffers::Vector<uint32_t> *peak_area() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_PEAK_AREA);
  }
  ::flatbuffers::Vector<uint32_t> *mutable_peak_area() {
    return GetPointer<::flatbuffers::Vector<uint32_t> *>(VT_PEAK_AREA);
  }
  const ::flatbuffers::Vector<uint32_t> *background() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_BACKGROUND);
  }
  ::flatbuffers::Vector<uint32_t> *mutable_background() {
    return GetPointer<::flatbuffers::Vector<uint32_t> *>(VT_BACKGROUND);
  }
  const ::flatbuffers::Vector<uint64_t> *threshold_time() const {
    return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_THRESHOLD_TIME);
  }
  ::flatbuffers::Vector<uint64_t> *mutable_threshold_time() {
    return GetPointer<::flatbuffers::Vector<uint64_t> *>(VT_THRESHOLD_TIME);
  }
  const ::flatbuffers::Vector<uint64_t> *peak_time() const {
    return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_PEAK_TIME);
  }
  ::flatbuffers::Vector<uint64_t> *mutable_peak_time() {
    return GetPointer<::flatbuffers::Vector<uint64_t> *>(VT_PEAK_TIME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AMPLITUDE) &&
           verifier.VerifyVector(amplitude()) &&
           VerifyOffset(verifier, VT_PEAK_AREA) &&
           verifier.VerifyVector(peak_area()) &&
           VerifyOffset(verifier, VT_BACKGROUND) &&
           verifier.VerifyVector(background()) &&
           VerifyOffset(verifier, VT_THRESHOLD_TIME) &&
           verifier.VerifyVector(threshold_time()) &&
           VerifyOffset(verifier, VT_PEAK_TIME) &&
           verifier.VerifyVector(peak_time()) &&
           verifier.EndTable();
  }
};

struct AdcPulseDebugBuilder {
  typedef AdcPulseDebug Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_amplitude(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> amplitude) {
    fbb_.AddOffset(AdcPulseDebug::VT_AMPLITUDE, amplitude);
  }
  void add_peak_area(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> peak_area) {
    fbb_.AddOffset(AdcPulseDebug::VT_PEAK_AREA, peak_area);
  }
  void add_background(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> background) {
    fbb_.AddOffset(AdcPulseDebug::VT_BACKGROUND, background);
  }
  void add_threshold_time(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> threshold_time) {
    fbb_.AddOffset(AdcPulseDebug::VT_THRESHOLD_TIME, threshold_time);
  }
  void add_peak_time(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> peak_time) {
    fbb_.AddOffset(AdcPulseDebug::VT_PEAK_TIME, peak_time);
  }
  explicit AdcPulseDebugBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AdcPulseDebug> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AdcPulseDebug>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AdcPulseDebug> CreateAdcPulseDebug(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> amplitude = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> peak_area = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> background = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> threshold_time = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> peak_time = 0) {
  AdcPulseDebugBuilder builder_(_fbb);
  builder_.add_peak_time(peak_time);
  builder_.add_threshold_time(threshold_time);
  builder_.add_background(background);
  builder_.add_peak_area(peak_area);
  builder_.add_amplitude(amplitude);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AdcPulseDebug> CreateAdcPulseDebugDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *amplitude = nullptr,
    const std::vector<uint32_t> *peak_area = nullptr,
    const std::vector<uint32_t> *background = nullptr,
    const std::vector<uint64_t> *threshold_time = nullptr,
    const std::vector<uint64_t> *peak_time = nullptr) {
  auto amplitude__ = amplitude ? _fbb.CreateVector<uint32_t>(*amplitude) : 0;
  auto peak_area__ = peak_area ? _fbb.CreateVector<uint32_t>(*peak_area) : 0;
  auto background__ = background ? _fbb.CreateVector<uint32_t>(*background) : 0;
  auto threshold_time__ = threshold_time ? _fbb.CreateVector<uint64_t>(*threshold_time) : 0;
  auto peak_time__ = peak_time ? _fbb.CreateVector<uint64_t>(*peak_time) : 0;
  return CreateAdcPulseDebug(
      _fbb,
      amplitude__,
      peak_area__,
      background__,
      threshold_time__,
      peak_time__);
}

#endif  // FLATBUFFERS_GENERATED_DTDBADCPULSEDEBUG_H_
